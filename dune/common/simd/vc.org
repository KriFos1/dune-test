|                         | Vector       | Vector    | SimdArray  | SimdArray | Masks[4]  |
|                         | <double> AVX | <int> SSE | <double,4> | <int,4>   |           |
|-------------------------+--------------+-----------+------------+-----------+-----------|
| V v(s);                 | y            | y         | y          | y         | y         |
| V v = s;                | y            | y         | y          | y         | *N*       |
| V v{s};                 | *N*          | y         | *N*        | *N*       | y         |
| V v = {s};              | *N*          | y         | *N*        | *N*       | *N*       |
|-------------------------+--------------+-----------+------------+-----------+-----------|
| v = s;                  | y            | y         | y          | y         | *N*       |
| v = {s};                | *N*          | *N*       | *N*        | *N*       | *N*       |
|-------------------------+--------------+-----------+------------+-----------+-----------|
| v++; ++v;               | y            | y         | *N*        | *N*       | y(n/a)[2] |
| v--; --v;               | y            | y         | *N*        | *N*       | n/a       |
|-------------------------+--------------+-----------+------------+-----------+-----------|
| +v; /* +[5]**/; -v;     | y            | y         | y          | y         | *N*       |
| !v;                     | y            | y         | y          | y         | y         |
| ~v;                     | n/a          | y         | n/a        | y         | *N*       |
|-------------------------+--------------+-----------+------------+-----------+-----------|
| sv @ sv; but see below  | y            | y         | y          | y         | *N*       |
|-------------------------+--------------+-----------+------------+-----------+-----------|
| s << v; s >> v;         | n/a          | *N*       | n/a        | *N*       | *N*       |
|-------------------------+--------------+-----------+------------+-----------+-----------|
| v == v; v != v;         | y            | y         | y          | y         | *N* [1]   |
|-------------------------+--------------+-----------+------------+-----------+-----------|
| v & v; v ^ v; v ¦ v;    | n/a          | y         | n/a        | y         | y         |
| sv && sv; sv ¦¦ sv;     | y            | y         | *N*        | *N*       | *N*       |
| v && v; v ¦¦ v;         | y            | y         | *N*        | *N*       | y         |
|-------------------------+--------------+-----------+------------+-----------+-----------|
| v @= sv; but see below  | y            | y         | y          | y         | *N*       |
| v &= v; v ^= v; v ¦= v; | n/a          | y         | n/a        | y         | y         |
|-------------------------+--------------+-----------+------------+-----------+-----------|
| v, v;[3]                | *N*          | *N*       | y          | y         | y         |

[1] The result of the mask-mask == and != operation is a scalar.
[2] ++ (either kind) on bools is deprecated by the standard
[3] contrary to the other operators, the expected result for (sv1, sv2) is
    exactly sv2, no broadcasting applied.
[4] Checked with Vector<int>::Mask [SSE] and SimdArray<int, 4>::Mask, which
    behaved identical
[5] Workaround for quirks in org-mode's rendering ;)

- y   :: operation generally works; some instances of the operation may not
         apply
- *N* :: operation generally does not work; some instances of the operation
         may not apply
- n/a :: operation does not apply (i.e. bitwise operations to floating-point
         operands, -- (and in the future possibly ++) to boolean operands,
         assignment operators to scalar left hand sides)

Each operation was tested with the full set of combinations of possible
const/non-const lvalue/xvalue arguments.  Each combination of constness and
value category was applied to the scalar type and the operation tried in an
SFINAE context; combinations that failed here were skipped for vector
arguments too.

|                         | Vectors | SimdArrays | Masks[4]  |
|                         |         |            |           |
|-------------------------+---------+------------+-----------|
| V v(s);                 | y       | y          | y         |
| V v = s;                | y       | y          | *N*       |
| V v{s};                 | *N*     | *N*        | y         |
| V v = {s};              | *N*     | *N*        | y         |
|-------------------------+---------+------------+-----------|
| v = s;                  | y       | y          | *N*       |
| v = {s};                | *N*     | *N*        | *N*       |
|-------------------------+---------+------------+-----------|
| v++; ++v;               | y       | *N*        | y(n/a)[2] |
| v--; --v;               | y       | *N*        | n/a       |
|-------------------------+---------+------------+-----------|
| +v; /* +[5]**/; -v;     | y       | y          | *N*       |
| !v;                     | y       | y          | y         |
| ~v;                     | y       | y          | *N*       |
|-------------------------+---------+------------+-----------|
| sv @ sv; but see below  | y       | y          | *N*       |
|-------------------------+---------+------------+-----------|
| s << v; s >> v;         | *N*     | *N*        | *N*       |
|-------------------------+---------+------------+-----------|
| v == v; v != v;         | y       | y          | *N* [1]   |
|-------------------------+---------+------------+-----------|
| v & v; v ^ v; v ¦ v;    | y       | y          | y         |
| v && v; v ¦¦ v;         | y       | *N*        | y         |
|-------------------------+---------+------------+-----------|
| v @= sv; but see below  | y       | y          | *N*       |
| v &= v; v ^= v; v ¦= v; | y       | y          | y         |
|-------------------------+---------+------------+-----------|
| v, v;[3]                | *N*     | y          | y         |

Restrictions:

- Use `V v(s)` for broadcast construction

Additional restrictions for vectors 

- Don't use ++ or -- (either kind), use +=Scalar<V>(1) / -=Scalar<V>(1)
  instead

- If you use << or >> with scalar arguments, broadcast them explicitly.

- Don't rely on conversion to mask in && and ||, convert explicitly instead.
  `!!v` should work but may be expensive.  `(v != Scalar<V>(0))` should work
  too, but may be too ugly.  `Mask<V>(v)` may work, but is untested.

  *TODO*: I should probably introduce an interface function mask() for this
  job.

- If you must use "operator,", explicitly convert the left argument to void.
  That may hide compiler warnings, but, well, you have already decided that
  you must use "operator," despite those warnings.

Additional restrictions for masks:

- Explicitly broadcast all arguments that may be scalar, e.g. `m @ M(b)`.

- This applies for broadcast assignement too!  Use `m = M(b)`

- The only operators that you can use are the binary operators &, ^, | and
  their assignment versions &=, ^=, |=, the logical operators &&, ||, and !,
  and the assignment =.  If you must, you can use the comma operator `,`.

- In particular you cannot use comparison operators == and !=.  If you can't
  live without them, instead of != use ^, and instead of == use `!(m1 ^ m2)`.

  *TODO*: I should probably introduce interface functions eq() and ne() to
  make this less arcane.
